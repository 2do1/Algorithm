## 2개 이하로 다른 비트

##### 문제 설명

양의 정수 `x`에 대한 함수 `f(x)`를 다음과 같이 정의합니다.

- `x`보다 크고 `x`와 **비트가 1~2개 다른** 수들 중에서 제일 작은 수

예를 들어,

- `f(2) = 3` 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

| 수   | 비트         | 다른 비트의 개수 |
| ---- | ------------ | ---------------- |
| 2    | `000...0010` |                  |
| 3    | `000...0011` | 1                |

- `f(7) = 11` 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

| 수   | 비트         | 다른 비트의 개수 |
| ---- | ------------ | ---------------- |
| 7    | `000...0111` |                  |
| 8    | `000...1000` | 4                |
| 9    | `000...1001` | 3                |
| 10   | `000...1010` | 3                |
| 11   | `000...1011` | 2                |

정수들이 담긴 배열 `numbers`가 매개변수로 주어집니다. `numbers`의 모든 수들에 대하여 각 수의 `f` 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- 1 ≤ `numbers`의 길이 ≤ 100,000
- 0 ≤ `numbers`의 모든 수 ≤ 1015

------

##### 입출력 예

| numbers | result   |
| ------- | -------- |
| `[2,7]` | `[3,11]` |

------

##### 입출력 예 설명

**입출력 예 #1**

- 문제 예시와 같습니다.

## 회고

이진수로 변환한뒤 모든 자리수를 비교하니 시간초과가 발생하였다.

이를 해결하기 위해 이진수로 변환하기 전 숫자가 홀수인지 짝수인지의 여부에 따라 나누어서 풀이하였다.

짝수인 경우 이진수의 일의 자리가 0이고, 홀수인 경우 이진수의 일의 자리가 1이다.

- 짝수인 경우 현재 수의 이진수 일의 자리를 1로 변경해주면 된다.(현재 수 + 1)

- 홀수인 경우 현재 수의 이진수에서 가장 오른쪽에 있는 0을 1로 변환해주고, 그 다음 숫자를 0으로 변환해주면 된다.

rfind() 함수는 문자열 끝에서부터 처음으로 발견되는 문자 또는 문자열의 위치를 반환해준다.

문자열을 찾지 못할 경우 -1을 반환한다.