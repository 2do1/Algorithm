# 부분수열의 합 

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 2 초      | 512 MB      | 8842 | 4197 | 2854      | 43.493%   |

## 문제

수열 S가 주어졌을 때, 수열 S의 부분 수열의 합으로 나올 수 없는 가장 작은 자연수를 구하는 프로그램을 작성하시오.

예를 들어, S = [5, 1, 2]인 경우에 1, 2, 3(=1+2), 5, 6(=1+5), 7(=2+5), 8(=1+2+5)을 만들 수 있다. 하지만, 4는 만들 수 없기 때문에 정답은 4이다.

## 입력

첫째 줄에 수열 S의 크기 N이 주어진다. (1 ≤ N ≤ 20)

둘째 줄에는 수열 S가 주어진다. S를 이루고있는 수는 100,000보다 작거나 같은 자연수이다.

## 출력

첫째 줄에 수열 S의 부분 수열의 합으로 나올 수 없는 가장 작은 자연수를 출력한다.

## 예제 입력 1 

```
3
5 1 2
```

## 예제 출력 1 

```
4
```

## 예제 입력 2 

```
3
2 1 4
```

## 예제 출력 2 

```
8
```

## 예제 입력 3 

```
4
2 1 2 7
```

## 예제 출력 3 

```
6
```

# 회고

itertools 라이브러리의 combinations() 함수를 이용하여 풀이하였다.

시간초과가 발생하였는데, in 함수를 사용한 것이 원인이었다.

리스트의 크기가 커지면 커질수록 in 함수를 이용할때 연산횟수가 매우 많아지기 때문이다.

이를 해결하기 위해 리스트에서 탐색을 진행하지 않고, 집합에서 탐색을 진행하였다.

일반적으로 list의 삽입, 제거, 탐색, 포함 여부는 보통 시간복잡도가 O(N)이고 dict와 set의 삽입, 제거, 탐색, 포함 여부는 시간복잡도가 O(1)이다.