# Maximum Subarray 

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 1 초      | 256 MB      | 7399 | 3132 | 2460      | 42.203%   |

## 문제

크기 N인 정수형 배열 X가 있을 때, X의 부분 배열(X의 연속한 일부분) 중 각 원소의 합이 가장 큰 부분 배열을 찾는 Maximum subarray problem(최대 부분배열 문제)은 컴퓨터 과학에서 매우 잘 알려져 있다.

여러분은 N과 배열 X가 주어졌을 때, X의 maximum subarray의 합을 구하자. 즉, max1 ≤ i ≤  j ≤ N (X[i]+...+X[j])를 구하자.

## 입력

입력 파일의 첫 번째 줄에 테스트 케이스의 수를 의미하는 자연수 T가 주어진다. 그 다음에는 T개의 테스트 케이스가 주어진다.

각 테스트케이스 별로 첫 번째 줄에 배열의 크기 N이 주어진다. (1 ≤ N ≤ 1,000)

그리고 두 번째 줄에 배열 X의 내용을 나타내는 N개의 정수가 공백으로 구분되어 주어진다. 이때 주어지는 수는 절댓값이 1,000보다 작은 정수이다.

## 출력

각 테스트케이스 별로 maximum subarray의 합을 줄로 구분하여 출력한다.

## 예제 입력 1 

```
2
5
1 2 3 4 5
5
2 1 -2 3 -5
```

## 예제 출력 1 

```
15
4
```

# 회고

점화식: dp[i] = max(n_list[i], dp[i - 1] + n_list[i])

문제에서 제공한 테스트 케이스는 맞았는데 계속 틀렸다고 해서 왜 틀렸을까 고민을 해보니 주어진 수가 모두 음수인 경우를 생각하지 못했다.

dp 테이블을 0으로 초기화해놔서 주어진 수가 모두 음수인 경우는 정답이 0으로 나왔다.

이를 해결하기 위해 dp 테이블을 절댓값이 큰 음수인 -1000으로 초기화 하거나, n개의 정수만큼 dp 테이블을 초기화하고 모든 범위의 dp 테이블 값을 채워나가는 식으로 하였다.

아직까지 반례나, 히든 테케를 찾는 것이 부족한 것 같다. 

더 문제를 많이 풀고, 문제를 풀 때 더 꼼꼼하게 모든 경우의 수를 고민해봐야할 것 같다.