# 원상 복구 (small) 

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 1 초      | 1024 MB     | 695  | 414  | 325       | 60.074%   |

## 문제

수가 적혀있는 P1, P2 .... PN N개의 카드가 있다.

1부터 N까지 수가 하나씩 존재하는 D1, D2 .... DN 가 있다. 이때 Di는 P{D_i} 값을 i 번째로 가지고 오는 것을 의미한다. 이러한 작업을 카드 섞기라고 부른다. 카드를 섞는 작업은 동시에 진행된다.

예를 들어, P1, P2 .... PN이 1, 4, 5, 3, 2이고, D1, D2 .... DN가 4, 3, 1, 2, 5라고 가정해보자. 이 카드를 한번 섞으면 3, 5, 1, 4, 2가 된다. 아래 그림에서 S는 카드를 한 번 섞은 후를 의미한다.

![img](https://upload.acmicpc.net/c315a95d-a165-4c50-ae75-7da607484771/-/crop/1167x696/355,193/-/preview/)

위 방식을 그대로 K번 섞은 카드의 정보와 D의 정보를 알고 있다고 할 때, 원래 카드는 어떤 배치를 이루고 있었는지 구해보자.

## 입력

첫번째 줄에는 카드의 개수 N과 카드를 섞은 횟수인 K가 공백으로 구분되어 주어진다.

두번째 줄에 K번 카드를 섞은 후 카드의 배치를 의미하는 Si가 공백으로 구분되어 총 N개 주어진다.

세번째 줄에는 총 N개의 Di이 공백으로 구분되어 주어진다.

## 출력

원래 카드의 배치를 P1부터 PN의 값들을 공백으로 구분해서 출력한다.

## 제한

-  1 ≤ N ≤ 10^4
-  1 ≤ K ≤ 10^3
-  1 ≤ Di ≤ N
-  1 ≤Pi, Si ≤ 10^6

## 예제 입력 1 

```
5 2
4 1 3 5 2
4 3 1 2 5
```

## 예제 출력 1 

```
1 4 5 3 2
```

## 예제 입력 2 

```
4 1
4 3 2 1
4 3 2 1
```

## 예제 출력 2 

```
1 2 3 4
```

# 회고

p[d[index] - 1] = s[index] 말고 p[index] = s[d[index] - 1]로 해서 처음에 틀렸었다. 둘다 테스트 케이스가 통과해서 처음에 맞은줄...

문제 이해하는게 넘 헷갈렸다..