# 아기 상어 2

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 2 초      | 512 MB      | 6071 | 2977 | 2237      | 47.606%   |

## 문제

N×M 크기의 공간에 아기 상어 여러 마리가 있다. 공간은 1×1 크기의 정사각형 칸으로 나누어져 있다. 한 칸에는 아기 상어가 최대 1마리 존재한다.

어떤 칸의 안전 거리는 그 칸과 가장 거리가 가까운 아기 상어와의 거리이다. 두 칸의 거리는 하나의 칸에서 다른 칸으로 가기 위해서 지나야 하는 칸의 수이고, 이동은 인접한 8방향(대각선 포함)이 가능하다.

안전 거리가 가장 큰 칸을 구해보자.

## 입력

첫째 줄에 공간의 크기 N과 M(2 ≤ N, M ≤ 50)이 주어진다. 둘째 줄부터 N개의 줄에 공간의 상태가 주어지며, 0은 빈 칸, 1은 아기 상어가 있는 칸이다. 빈 칸과 상어의 수가 각각 한 개 이상인 입력만 주어진다.

## 출력

첫째 줄에 안전 거리의 최댓값을 출력한다.

## 예제 입력 1

```
5 4
0 0 1 0
0 0 0 0
1 0 0 0
0 0 0 0
0 0 0 1
```

## 예제 출력 1

```
2
```

## 예제 입력 2

```
7 4
0 0 0 1
0 1 0 0
0 0 0 0
0 0 0 1
0 0 0 0
0 1 0 0
0 0 0 1
```

## 예제 출력 2

```
2
```

# 회고

BFS 알고리즘을 이용하여 풀이했다.

빈 칸일때마다 BFS 탐색을 진행하려고 하였으나, 아기 상어가 있는 칸에서 BFS를 탐색하는 것이 더 효율적이었다.

문제 풀이 방법에는 크게 2가지가 있는것 같다.

첫번째 방법으로는 아기 상어의 위치를 큐에 하나씩 넣어가면서 진행하는 것이다.

이 방식대로 하려면 다음 상어를 탐색할 때 이전의 상어가 적어둔 거리보다 가까우면 업데이트를 해줬어야 했다.

두번째 방법으로는 상어의 위치를 한꺼번에 큐에 넣어둔 뒤에 탐색을 진행하는 것이다.

다음 블로그 [velog](https://velog.io/@emily2307/%EB%B0%B1%EC%A4%80-17086-%EC%95%84%EA%B8%B0-%EC%83%81%EC%96%B4-2)의 글을 통해 풀이를 이해할 수 있었다.
